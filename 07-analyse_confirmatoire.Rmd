---
output:
  pdf_document: default
  html_document: default
---

# Approches causales {#conf}

```{r simul_2, cache=TRUE, include=FALSE}

# je refais tourner parce que ça ne marche pas sinon

  rm(list=ls())

  param.causal.model <- function(p_L1 = 0.50, 
                                 p_L2 = 0.20, 
                                 p_L3 = 0.70,       # baseline confounders
                                 b_A1 = 0.10, 
                                 b_L1_A1 = 0.15, 
                                 b_L2_A1 = 0.25, # modèle de A1
                                 b_A2 = 0.15, 
                                 b_L1_A2 = 0.20, 
                                 b_L3_A2 = 0.20, # modèle de A2
                                 b_Y = 0.10,      # modèle de Y
                                 b_L1_Y = 0.02,
                                 b_L2_Y = 0.02,
                                 b_L3_Y = -0.02,
                                 b_A1_Y = 0.3,
                                 b_A2_Y = 0.1,
                                 b_A1A2_Y = 0.4 ) { # <- effet d'interaction Delta)

  # coefficients pour simuler l'exposition
  # exposition A1  # vérif
  try(if(b_A1 + b_L1_A1 + b_L1_A1 > 1) 
    stop("la somme des coefficient du modèle A1 dépasse 100%"))
  
  # exposition A2  # vérif
  try(if(b_A2 + b_L1_A2 + b_L3_A2 > 1) 
    stop("la somme des coefficients du modèle A2 dépasse 100%"))
  
  # coefficients pour simuler l'outcome, vérif
  try(if(b_Y + b_L1_Y + b_L2_Y + b_L3_Y + b_A1_Y + b_A2_Y + b_A1A2_Y > 1) 
    stop("la somme des coefficients du modèle Y dépasse 100%"))
  try(if(b_Y + b_L1_Y + b_L2_Y + b_L3_Y + b_A1_Y + b_A2_Y + b_A1A2_Y < 0) 
    stop("la somme des coefficients du modèle Y est inférieure à 0%"))
  
  coef <- list(c(p_L1 = p_L1, p_L2 = p_L2, p_L3 = p_L3),
               c(b_A1 = b_A1, b_L1_A1 = b_L1_A1, b_L2_A1 = b_L2_A1),
               c(b_A2 = b_A2, b_L1_A2 = b_L1_A2, b_L3_A2 = b_L3_A2),
               c(b_Y = b_Y, b_L1_Y = b_L1_Y, b_L2_Y = b_L2_Y, b_L3_Y = b_L3_Y,
                 b_A1_Y = b_A1_Y, b_A2_Y = b_A2_Y, b_A1A2_Y = b_A1A2_Y))
  return(coef)
}

generate.data <- function(N, b =  param.causal.model()) {
  
  L1 <- rbinom(N, size = 1, prob = b[[1]]["p_L1"]) 
  L2 <- rbinom(N, size = 1, prob = b[[1]]["p_L2"])
  L3 <- rbinom(N, size = 1, prob = b[[1]]["p_L3"])
  A1 <- rbinom(N, size = 1, prob = b[[2]]["b_A1"] + 
                 (b[[2]]["b_L1_A1"] * L1) + (b[[2]]["b_L2_A1"] * L2))
  A2 <- rbinom(N, size = 1, prob = b[[3]]["b_A2"] + 
                 (b[[3]]["b_L1_A2"] * L1) + (b[[3]]["b_L3_A2"] * L3))
  Y <- rbinom(N, size = 1, prob = (b[[4]]["b_Y"] + 
                                     (b[[4]]["b_L1_Y"] * L1) + 
                                     (b[[4]]["b_L2_Y"] * L2) +
                                     (b[[4]]["b_L3_Y"] * L3) +  
                                     (b[[4]]["b_A1_Y"] * A1) + 
                                     (b[[4]]["b_A2_Y"] * A2) + 
                                     (b[[4]]["b_A1A2_Y"] * A1 * A2)) )
  data.sim <- data.frame(L1, L2, L3, A1, A2, Y)
  return(data.sim)
}

```

## Estimation par G-computation {#gcomputation}

Il s'agit d'une "G-méthode" qui peut être décrite comme une "standardisation" par régression (Hernàn @hernan2020causal). 
Le principe est le suivant :

  i) Modéliser le critère de jugement en fonction des deux expositions d'intérêt, de leur interaction et des facteurs de confusion
\begin{equation*}
  \overline{Q}(A_1,A_2,L) = \mathbb{E}(Y | A_1, A_2, L_1,L_2,L_3)
\end{equation*}
  ii) A partir de ce modèle $\overline{Q}$, estimer pour chaque individu $i$ les valeurs moyennes attendues (contrefactuelles) $\overline{Q}_i(0,0,L)$, $\overline{Q}_i(1,0,L)$, $\overline{Q}_i(0,1,L)$ et $\overline{Q}_i(1,1,L)$, sous les 4 scénarios possibles $\{A_1 = 0, A_2 = 0\}$, $\{A_1 = 1, A_2 = 0\}$, $\{A_1 = 0, A_2 = 1\}$ et $\{A_1 = 1, A_2 = 1\}$.
  iii) Utiliser les moyennes contrefactuelles estimées pour calculer les différents indicateurs d'intérêt pour l'analyse d'interaction : 
  
- Les moyennes marginales pour chaque case du tableau d'interaction
\begin{align*}
  p_{00} &= \frac{1}{n} \sum \overline{Q}_i(0,0,L) \\
  p_{10} &= \frac{1}{n} \sum \overline{Q}_i(1,0,L) \\
  p_{01} &= \frac{1}{n} \sum \overline{Q}_i(0,1,L) \\
  p_{11} &= \frac{1}{n} \sum \overline{Q}_i(1,1,L) 
\end{align*}
          
- Les différences de risques marginales
\begin{align*}
  DR(A_1, A_2 = 0) &= p_{10} - p_{00} \\
  DR(A_1, A_2 = 1) &= p_{11} - p_{01} \\
  DR(A_2, A_1 = 0) &= p_{01} - p_{00} \\
  DR(A_2, A_1 = 1) &= p_{11} - p_{10}
\end{align*}
          
- Les risques relatifs marginaux
\begin{align*}
  RR(A_1, A_2 = 0) &= p_{10} / p_{00} \\
  RR(A_1, A_2 = 1) &= p_{11} / p_{01} \\
  RR(A_2, A_1 = 0) &= p_{01} / p_{00} \\
  RR(A_2, A_1 = 1) &= p_{11} / p_{10}
\end{align*}  
          
- Les mesures d'interaction
\begin{align*}
  MI &= \frac{p_{11} \times p_{00}}{p_{10} \times p_{01}} \\
  AI &= p_{11} - p_{10} - p_{01} + p_{00} \\
  RERI &= \frac{p_{11} - p_{10} - p_{01} + p_{00}}{p_{00}}
\end{align*} 
           

<script type="text/javascript">

// toggle visibility of R source blocks in R Markdown output
function toggle_R() {
  var x = document.getElementsByClassName('r');
  if (x.length == 0) return;
  function toggle_vis(o) {
    var d = o.style.display;
    o.style.display = (d == 'block' || d == '') ? 'none':'block';
  }

  for (i = 0; i < x.length; i++) {
    var y = x[i];
    if (y.tagName.toLowerCase() === 'pre') toggle_vis(y);
  }

    var elem = document.getElementById("myButton1");
    if (elem.value === "Hide Code") elem.value = "Show Code";
    else elem.value = "Hide Code";
}

document.write('<input onclick="toggle_R();" type="button" value="Hide Code" id="myButton1" style="position: static; top: 1%; left: 2%; z-index: 200"></input>')

</script>

```{r gcomp, cache=FALSE, results='hide'}

## i) Modéliser le critère de jugement en fonction des deux expositions d'intérêt, 
##    de leur interaction et des facteurs de confusion
    model.Y <- glm(Y ~ L1 + L2 + L3 + A1 + A2 + A1:A2, data = df, family = "binomial")

    # dans cette exemple, les données étaient simulées à partir d'un modèle additif, 
    # le modèle plus adapté serait donc plutôt le suivant : 
    # model.Y <- glm(Y ~ L1 + L2 + L3 + A1 + A2 + A1:A2, data = df,
    #                family = "gaussian") 
    # (en pratique, on ne connaît pas la nature du modèle générateur des données)

## ii) Estimer les valeurs attendues sous les 4 scenarios contrefactuels
## ii.a) on crée 4 bases de données correspondant aux 4 scenarios contrefactuels
    df.A1_0.A2_0 <- df.A1_1.A2_0 <- df.A1_0.A2_1 <- df.A1_1.A2_1 <- df

    # scénario do(A1 = 0, A2 = 0) pour toute la population
    df.A1_0.A2_0$A1 <- df.A1_0.A2_0$A2 <- rep(0, nrow(df))
    
    # scénario do(A1 = 1, A2 = 0) pour toute la population
    df.A1_1.A2_0$A1 <- rep(1, nrow(df))
    df.A1_1.A2_0$A2 <- rep(0, nrow(df))
    
    # scénario do(A1 = 0, A2 = 1) pour toute la population
    df.A1_0.A2_1$A1 <- rep(0, nrow(df))
    df.A1_0.A2_1$A2 <- rep(1, nrow(df))

    # scénario do(A1 = 1, A2 = 1) pour toute la population
    df.A1_1.A2_1$A1 <- df.A1_1.A2_1$A2 <- rep(1, nrow(df))

## ii.b) on prédit le critère de jugement sous les scenarios contrefactuels
    Qbar_00 <- predict(model.Y, newdata = df.A1_0.A2_0, type = "response")
    Qbar_10 <- predict(model.Y, newdata = df.A1_1.A2_0, type = "response")
    Qbar_01 <- predict(model.Y, newdata = df.A1_0.A2_1, type = "response")
    Qbar_11 <- predict(model.Y, newdata = df.A1_1.A2_1, type = "response")

    
## iii) Utiliser les moyennes contrefactuelles estimées pour calculer les différents 
##      indicateurs d'intérêt pour l'analyse d'interaction
## iii.a) on va enregistrer l'ensemble des résultats pertinents dans une table 'int.r'
##        de longueur 2 x 2
    int.r <- matrix(NA,
                    ncol = 26,
                    nrow = nlevels(as.factor(df$A1)) * nlevels(as.factor(df$A2)))
    int.r <- as.data.frame(int.r)
    names(int.r) <- c("A1","A2","p","p.lo","p.up",
                      "RD.A1","RD.A1.lo","RD.A1.up","RD.A2","RD.A2.lo","RD.A2.up",
                      "RR.A1","RR.A1.lo","RR.A1.up","RR.A2","RR.A2.lo","RR.A2.up",
                      "a.INT", "a.INT.lo", "a.INT.up","RERI","RERI.lo","RERI.up",
                      "m.INT", "m.INT.lo", "m.INT.up" )
    int.r[,c("A1","A2")] <- expand.grid(c(0,1), c(0,1))

## iii.b) Les moyennes marginales pour chaque case du tableau d’interaction
# dans chaque case de la table 2 x 2
    # A1 = 0 et A2 = 0
    int.r$p[int.r$A1 == 0 & int.r$A2 == 0] <- mean(Qbar_00)
    # A1 = 1 et A2 = 0
    int.r$p[int.r$A1 == 1 & int.r$A2 == 0] <- mean(Qbar_10)
    # A1 = 0 et A2 = 1
    int.r$p[int.r$A1 == 0 & int.r$A2 == 1] <- mean(Qbar_01)
    # A1 = 1 et A2 = 1
    int.r$p[int.r$A1 == 1 & int.r$A2 == 1] <- mean(Qbar_11)

## iii.c) Les différences de risques marginales
    # RD.A1.A2is0
    int.r$RD.A1[int.r$A1 == 1 & int.r$A2 == 0] <- mean(Qbar_10) - mean(Qbar_00)
    # RD.A1.A2is1
    int.r$RD.A1[int.r$A1 == 1 & int.r$A2 == 1] <- mean(Qbar_11) - mean(Qbar_01)
    # RD.A2.A1is0
    int.r$RD.A2[int.r$A1 == 0 & int.r$A2 == 1] <- mean(Qbar_01) - mean(Qbar_00)
    # RD.A2.A1is1
    int.r$RD.A2[int.r$A1 == 1 & int.r$A2 == 1] <- mean(Qbar_11) - mean(Qbar_10)

## iii.d) Les risques relatifs marginaux
    # RR.A1.A2is0
    int.r$RR.A1[int.r$A1 == 1 & int.r$A2 == 0] <- mean(Qbar_10) / mean(Qbar_00)
    # RR.A1.A2is1
    int.r$RR.A1[int.r$A1 == 1 & int.r$A2 == 1] <- mean(Qbar_11) / mean(Qbar_01)
    # RR.A2.A1is0
    int.r$RR.A2[int.r$A1 == 0 & int.r$A2 == 1] <- mean(Qbar_01) / mean(Qbar_00)
    # RR.A2.A1is1
    int.r$RR.A2[int.r$A1 == 1 & int.r$A2 == 1] <- mean(Qbar_11) / mean(Qbar_10)

## iii.e) Les mesures d'interaction
    # additive interaction
    int.r$a.INT[int.r$A1 == 1 & int.r$A2 == 1] <- mean(Qbar_11) -
                                                  mean(Qbar_10) -
                                                  mean(Qbar_01) +
                                                  mean(Qbar_00)
    # RERI
    int.r$RERI[int.r$A1 == 1 & int.r$A2 == 1] <- (mean(Qbar_11) -
                                                    mean(Qbar_10) -
                                                    mean(Qbar_01) +
                                                    mean(Qbar_00)) /
                                                    mean(Qbar_00)
    # multiplicative interaction
    int.r$m.INT[int.r$A1 == 1 & int.r$A2 == 1] <- (mean(Qbar_11) *
                                                   mean(Qbar_00)) /
                                                   (mean(Qbar_10) *
                                                    mean(Qbar_01))


## iii.f) Calcul des intervalles de confiance 
    # Le script ci-dessous présente une méthode de bootstrap 
    # pour calculer les intervalles de confiance à 95% des différents indicateurs
    set.seed(5678)
    B <- 1000 # on utilise 1000 échantillons boostrap dans cet exemple
    bootstrap.est <- data.frame(matrix(NA, nrow = B, ncol = 15))
    colnames(bootstrap.est) <- c("p.A1is0.A2is0", "p.A1is1.A2is0", 
                                 "p.A1is0.A2is1", "p.A1is1.A2is1",
                                 "RD.A1.A2is0", "RD.A1.A2is1", 
                                 "RD.A2.A1is0", "RD.A2.A1is1",
                                 "lnRR.A1.A2is0", "lnRR.A1.A2is1", 
                                 "lnRR.A2.A1is0", "lnRR.A2.A1is1",
                                 "INT.a", "lnRERI", "lnINT.m")

    for (b in 1:B){ # on refait toute l'analyse dans chaque échantillon bootstrap
      # constituer un échantillon bootstrap (échantillonnage avec remise)
      bootIndices <- sample(1:nrow(df), replace=T)
      bootData <- df[bootIndices,]

      if ( round(b/100, 0) == b/100 ) print(paste0("bootstrap number ",b))

      # étape (i) de modélisation du critère de jugement
      model.Y <- glm(Y ~ L1 + L2 + L3 + A1 + A2 + A1:A2,
                     data = bootData,                    # use BootData here +++
                     family = "binomial")

      # étape (ii) d'estimation des valeurs attendus sous les 4 scénarios contrefactuels
      boot.A1_0.A2_0 <- boot.A1_1.A2_0 <- boot.A1_0.A2_1 <- boot.A1_1.A2_1 <- bootData
      boot.A1_0.A2_0$A1 <- boot.A1_0.A2_0$A2 <- rep(0, nrow(df))
      boot.A1_1.A2_0$A1 <- rep(1, nrow(df))
      boot.A1_1.A2_0$A2 <- rep(0, nrow(df))
      boot.A1_0.A2_1$A1 <- rep(0, nrow(df))
      boot.A1_0.A2_1$A2 <- rep(1, nrow(df))
      boot.A1_1.A2_1$A1 <- boot.A1_1.A2_1$A2 <- rep(1, nrow(df))

      # prédire les résultats contrefactuels sous les différents scénarios
      Qbar_00 <- predict(model.Y, newdata = boot.A1_0.A2_0, type = "response")
      Qbar_10 <- predict(model.Y, newdata = boot.A1_1.A2_0, type = "response")
      Qbar_01 <- predict(model.Y, newdata = boot.A1_0.A2_1, type = "response")
      Qbar_11 <- predict(model.Y, newdata = boot.A1_1.A2_1, type = "response")

      # étape (iii) de calcul des différents indicateurs d'intérêt
      # on sauve les résultats dans la table bootstrap.est
      bootstrap.est[b,"p.A1is0.A2is0"] <- mean(Qbar_00)
      bootstrap.est[b,"p.A1is1.A2is0"] <- mean(Qbar_10)
      bootstrap.est[b,"p.A1is0.A2is1"] <- mean(Qbar_01)
      bootstrap.est[b,"p.A1is1.A2is1"] <- mean(Qbar_11)

      bootstrap.est[b,"RD.A1.A2is0"] <- mean(Qbar_10) - mean(Qbar_00)
      bootstrap.est[b,"RD.A1.A2is1"] <- mean(Qbar_11) - mean(Qbar_01)
      bootstrap.est[b,"RD.A2.A1is0"] <- mean(Qbar_01) - mean(Qbar_00)
      bootstrap.est[b,"RD.A2.A1is1"] <- mean(Qbar_11) - mean(Qbar_10)
      
      # les Ic95% des RR sont d'abord calculés sur une échelle logarithmique
      bootstrap.est[b,"lnRR.A1.A2is0"] <- log(mean(Qbar_10) / mean(Qbar_00))
      bootstrap.est[b,"lnRR.A1.A2is1"] <- log(mean(Qbar_11) / mean(Qbar_01))
      bootstrap.est[b,"lnRR.A2.A1is0"] <- log(mean(Qbar_01) / mean(Qbar_00))
      bootstrap.est[b,"lnRR.A2.A1is1"] <- log(mean(Qbar_11) / mean(Qbar_10))

      bootstrap.est[b,"INT.a"] <- (mean(Qbar_11) -
                                     mean(Qbar_10) - mean(Qbar_01) + mean(Qbar_00))
      # les IC95% du RERI et de l'interaction multiplicative sont d'abord calculés
      # sur une échelle logarithmique
      bootstrap.est[b,"lnRERI"] <- log((mean(Qbar_11) -
                                          mean(Qbar_10) - mean(Qbar_01) + mean(Qbar_00)) 
                                       / mean(Qbar_00))
      bootstrap.est[b,"lnINT.m"] <- log((mean(Qbar_11) * mean(Qbar_00)) / 
                                           (mean(Qbar_10) * mean(Qbar_01)))
    }
    
    ## On peut vérifier la normalité des distributions bootstrap avec le script 
    ## proposé en commentaire ci-dessous :
    
    # par(mfrow = c(4,4))
    # for(c in 1:ncol(bootstrap.est)) {
    #   hist(bootstrap.est[,c], freq = FALSE, main = names(bootstrap.est)[c])
    #   lines(density(bootstrap.est[,c]), col = 2, lwd = 3)
    #   curve(1/sqrt(var(bootstrap.est[,c]) * 2 * pi) *
    #           exp(-1/2 * ((x-mean(bootstrap.est[,c])) / sd(bootstrap.est[,c]))^2),
    #         col = 1, lwd = 2, lty = 2, add = TRUE)
    # par(mfrow = c(1,1))
    # }
    
    # Les distributions ont bien une allure normale, on peut donc utiliser la 
    # déviation standard des distributions pour calculer les IC95%.
    # En cas de distributions asymétriques, il serait préférable d'utiliser les 
    # percentiles 2.5% et 97.5% (ou un méthode bootstrap BCa)

## on calcule les IC95% et on les intègre dans la table de synthèse 'int.r'
    # A1 = 0 et A2 = 0
    int.r$p.lo[int.r$A1 == 0 & int.r$A2 == 0] <- int.r$p[int.r$A1 == 0 & int.r$A2 == 0] -
      qnorm(0.975) * sd(bootstrap.est$p.A1is0.A2is0)
    int.r$p.up[int.r$A1 == 0 & int.r$A2 == 0] <- int.r$p[int.r$A1 == 0 & int.r$A2 == 0] +
      qnorm(0.975) * sd(bootstrap.est$p.A1is0.A2is0)
    # A1 = 1 et A2 = 0
    int.r$p.lo[int.r$A1 == 1 & int.r$A2 == 0] <- int.r$p[int.r$A1 == 1 & int.r$A2 == 0] -
      qnorm(0.975) * sd(bootstrap.est$p.A1is1.A2is0)
    int.r$p.up[int.r$A1 == 1 & int.r$A2 == 0] <- int.r$p[int.r$A1 == 1 & int.r$A2 == 0] +
      qnorm(0.975) * sd(bootstrap.est$p.A1is1.A2is0)
    # A1 = 0 et A2 = 1
    int.r$p.lo[int.r$A1 == 0 & int.r$A2 == 1] <- int.r$p[int.r$A1 == 0 & int.r$A2 == 1] -
      qnorm(0.975) * sd(bootstrap.est$p.A1is0.A2is1)
    int.r$p.up[int.r$A1 == 0 & int.r$A2 == 1] <- int.r$p[int.r$A1 == 0 & int.r$A2 == 1] +
      qnorm(0.975) * sd(bootstrap.est$p.A1is0.A2is1)
    # A1 = 1 et A2 = 1
    int.r$p.lo[int.r$A1 == 1 & int.r$A2 == 1] <- int.r$p[int.r$A1 == 1 & int.r$A2 == 1] -
      qnorm(0.975) * sd(bootstrap.est$p.A1is1.A2is1)
    int.r$p.up[int.r$A1 == 1 & int.r$A2 == 1] <- int.r$p[int.r$A1 == 1 & int.r$A2 == 1] +
      qnorm(0.975) * sd(bootstrap.est$p.A1is1.A2is1)

# risk difference
    # RD.A1.A2is0
    int.r$RD.A1.lo[int.r$A1 == 1 & 
                     int.r$A2 == 0] <- (int.r$RD.A1[int.r$A1 == 1 & int.r$A2 == 0] -
                                          qnorm(0.975) * sd(bootstrap.est$RD.A1.A2is0))
    int.r$RD.A1.up[int.r$A1 == 1 & 
                     int.r$A2 == 0] <- (int.r$RD.A1[int.r$A1 == 1 & int.r$A2 == 0] +
                                          qnorm(0.975) * sd(bootstrap.est$RD.A1.A2is0))
    # RD.A1.A2is1
    int.r$RD.A1.lo[int.r$A1 == 1 & 
                     int.r$A2 == 1] <- (int.r$RD.A1[int.r$A1 == 1 & int.r$A2 == 1] -
                                          qnorm(0.975) * sd(bootstrap.est$RD.A1.A2is1))
    int.r$RD.A1.up[int.r$A1 == 1 & 
                     int.r$A2 == 1] <- (int.r$RD.A1[int.r$A1 == 1 & int.r$A2 == 1] +
                                          qnorm(0.975) * sd(bootstrap.est$RD.A1.A2is1))
    # RD.A2.A1is0
    int.r$RD.A2.lo[int.r$A1 == 0 & 
                     int.r$A2 == 1] <- (int.r$RD.A2[int.r$A1 == 0 & int.r$A2 == 1] -
                                          qnorm(0.975) * sd(bootstrap.est$RD.A2.A1is0))
    int.r$RD.A2.up[int.r$A1 == 0 & 
                     int.r$A2 == 1] <- (int.r$RD.A2[int.r$A1 == 0 & int.r$A2 == 1] +
                                          qnorm(0.975) * sd(bootstrap.est$RD.A2.A1is0))
    # RD.A2.A1is1
    int.r$RD.A2.lo[int.r$A1 == 1 & 
                     int.r$A2 == 1] <- (int.r$RD.A2[int.r$A1 == 1 & int.r$A2 == 1] -
                                          qnorm(0.975) * sd(bootstrap.est$RD.A2.A1is1))
    int.r$RD.A2.up[int.r$A1 == 1 & 
                     int.r$A2 == 1] <- (int.r$RD.A2[int.r$A1 == 1 & int.r$A2 == 1] +
                                          qnorm(0.975) * sd(bootstrap.est$RD.A2.A1is1))

# relative risk
    # RR.A1.A2is0
    int.r$RR.A1.lo[int.r$A1 == 1 & 
                     int.r$A2 == 0] <- exp(log(int.r$RR.A1[int.r$A1 == 1 & int.r$A2 == 0]) -
                                                           qnorm(0.975) * 
                                             sd(bootstrap.est$lnRR.A1.A2is0))
    int.r$RR.A1.up[int.r$A1 == 1 & 
                     int.r$A2 == 0] <- exp(log(int.r$RR.A1[int.r$A1 == 1 & int.r$A2 == 0]) +
                                                           qnorm(0.975) * 
                                             sd(bootstrap.est$lnRR.A1.A2is0))
    # RR.A1.A2is1
    int.r$RR.A1.lo[int.r$A1 == 1 & 
                     int.r$A2 == 1] <- exp(log(int.r$RR.A1[int.r$A1 == 1 & int.r$A2 == 1]) -
                                                           qnorm(0.975) * 
                                             sd(bootstrap.est$lnRR.A1.A2is1))
    int.r$RR.A1.up[int.r$A1 == 1 & 
                     int.r$A2 == 1] <- exp(log(int.r$RR.A1[int.r$A1 == 1 & int.r$A2 == 1]) +
                                                           qnorm(0.975) * 
                                             sd(bootstrap.est$lnRR.A1.A2is1))
    # RR.A2.A1is0
    int.r$RR.A2.lo[int.r$A1 == 0 & 
                     int.r$A2 == 1] <- exp(log(int.r$RR.A2[int.r$A1 == 0 & int.r$A2 == 1]) -
                                                           qnorm(0.975) * 
                                             sd(bootstrap.est$lnRR.A2.A1is0))
    int.r$RR.A2.up[int.r$A1 == 0 & 
                     int.r$A2 == 1] <- exp(log(int.r$RR.A2[int.r$A1 == 0 & int.r$A2 == 1]) +
                                                           qnorm(0.975) * 
                                             sd(bootstrap.est$lnRR.A2.A1is0))
    # RR.A2.A1is1
    int.r$RR.A2.lo[int.r$A1 == 1 & 
                     int.r$A2 == 1] <- exp(log(int.r$RR.A2[int.r$A1 == 1 & int.r$A2 == 1]) -
                                                           qnorm(0.975) * 
                                             sd(bootstrap.est$lnRR.A2.A1is1))
    int.r$RR.A2.up[int.r$A1 == 1 & 
                     int.r$A2 == 1] <- exp(log(int.r$RR.A2[int.r$A1 == 1 & int.r$A2 == 1]) +
                                                           qnorm(0.975) * 
                                             sd(bootstrap.est$lnRR.A2.A1is1))

# additive interaction
    int.r$a.INT.lo[int.r$A1 == 1 & 
                     int.r$A2 == 1] <- (int.r$a.INT[int.r$A1 == 1 & int.r$A2 == 1] -
                                          qnorm(0.975) * sd(bootstrap.est$INT.a))
    int.r$a.INT.up[int.r$A1 == 1 & 
                     int.r$A2 == 1] <- (int.r$a.INT[int.r$A1 == 1 & int.r$A2 == 1] +
                                          qnorm(0.975) * sd(bootstrap.est$INT.a))
# RERI
    int.r$RERI.lo[int.r$A1 == 1 & 
                    int.r$A2 == 1] <- exp(log(int.r$RERI[int.r$A1 == 1 & int.r$A2 == 1]) -
                                            qnorm(0.975) * sd(bootstrap.est$lnRERI))
    int.r$RERI.up[int.r$A1 == 1 & 
                    int.r$A2 == 1] <- exp(log(int.r$RERI[int.r$A1 == 1 & int.r$A2 == 1]) +
                                            qnorm(0.975) * sd(bootstrap.est$lnRERI))
# multiplicative interaction
    int.r$m.INT.lo[int.r$A1 == 1 & 
                     int.r$A2 == 1] <- exp(log(int.r$m.INT[int.r$A1 == 1 & int.r$A2 == 1]) -
                                             qnorm(0.975) * sd(bootstrap.est$lnINT.m))
    int.r$m.INT.up[int.r$A1 == 1 & 
                     int.r$A2 == 1] <- exp(log(int.r$m.INT[int.r$A1 == 1 & int.r$A2 == 1]) +
                                             qnorm(0.975) * sd(bootstrap.est$lnINT.m))
```

Au final, on a : 

<script type="text/javascript">

// toggle visibility of R source blocks in R Markdown output
function toggle_R() {
  var x = document.getElementsByClassName('r');
  if (x.length == 0) return;
  function toggle_vis(o) {
    var d = o.style.display;
    o.style.display = (d == 'block' || d == '') ? 'none':'block';
  }

  for (i = 0; i < x.length; i++) {
    var y = x[i];
    if (y.tagName.toLowerCase() === 'pre') toggle_vis(y);
  }

    var elem = document.getElementById("myButton1");
    if (elem.value === "Hide Code") elem.value = "Show Code";
    else elem.value = "Hide Code";
}

document.write('<input onclick="toggle_R();" type="button" value="Hide Code" id="myButton1" style="position: static; top: 1%; left: 2%; z-index: 200"></input>')

</script>

```{r t_gcomp, echo=TRUE, message=FALSE, warning=FALSE}
## On peut présenter les différents résultats dans un tableau des effets marginaux
    out.table <- data.frame(c1 = rep("",4), c2 = rep("",4), c3 = rep("",4), c4 = rep("",4))
    names(out.table) <- c("A2=0", "A2=1", "RD.A2|A1", "RR.A2|A1")
    rownames(out.table) <- c("A1=0", "A1=1", "RD.A1|A2", "RR.A1|A2")
# p
    out.table["A1=0","A2=0"] <- paste0("$p_{00}$=",
                                       round(int.r$p[which(int.r$A1==0 & int.r$A2==0)], 
                                             digits = 3), " [",
                                       round(int.r$p.lo[which(int.r$A1==0 & int.r$A2==0)], 
                                             digits = 3), ",",
                                       round(int.r$p.up[which(int.r$A1==0 & int.r$A2==0)], 
                                             digits = 3), "]")
    out.table["A1=0","A2=1"] <- paste0("$p_{01}$=",round(int.r$p[which(int.r$A1==0 & 
                                                                         int.r$A2==1)], 
                                                         digits = 3), " [",
                                       round(int.r$p.lo[which(int.r$A1==0 & int.r$A2==1)], 
                                             digits = 3), ",",
                                       round(int.r$p.up[which(int.r$A1==0 & int.r$A2==1)], 
                                             digits = 3), "]")
    out.table["A1=1","A2=0"] <- paste0("$p_{10}$=",round(int.r$p[which(int.r$A1==1 & 
                                                                         int.r$A2==0)], 
                                                         digits = 3), " [",
                                       round(int.r$p.lo[which(int.r$A1==1 & int.r$A2==0)], 
                                             digits = 3), ",",
                                       round(int.r$p.up[which(int.r$A1==1 & int.r$A2==0)], 
                                             digits = 3), "]")
    out.table["A1=1","A2=1"] <- paste0("$p_{11}$=",round(int.r$p[which(int.r$A1==1 & 
                                                                         int.r$A2==1)], 
                                                         digits = 3), " [",
                                       round(int.r$p.lo[which(int.r$A1==1 & int.r$A2==1)], 
                                             digits = 3), ",",
                                       round(int.r$p.up[which(int.r$A1==1 & int.r$A2==1)], 
                                             digits = 3), "]")
# RD
    out.table["A1=0","RD.A2|A1"] <- paste0(round(int.r$RD.A2[which(int.r$A1==0 & 
                                                                     int.r$A2==1)], 
                                                 digits = 3), " [",
                                           round(int.r$RD.A2.lo[which(int.r$A1==0 & 
                                                                        int.r$A2==1)], 
                                                 digits = 3), ",",
                                           round(int.r$RD.A2.up[which(int.r$A1==0 & 
                                                                        int.r$A2==1)], 
                                                 digits = 3), "]")
    out.table["A1=1","RD.A2|A1"] <- paste0(round(int.r$RD.A2[which(int.r$A1==1 & 
                                                                     int.r$A2==1)], 
                                                 digits = 3), " [",
                                           round(int.r$RD.A2.lo[which(int.r$A1==1 & 
                                                                        int.r$A2==1)], 
                                                 digits = 3), ",",
                                           round(int.r$RD.A2.up[which(int.r$A1==1 & 
                                                                        int.r$A2==1)], 
                                                 digits = 3), "]")
    out.table["RD.A1|A2","A2=0"] <- paste0(round(int.r$RD.A1[which(int.r$A1==1 & 
                                                                     int.r$A2==0)],
                                                 digits = 3), " [",
                                           round(int.r$RD.A1.lo[which(int.r$A1==1 & 
                                                                        int.r$A2==0)],
                                                 digits = 3), ",",
                                           round(int.r$RD.A1.up[which(int.r$A1==1 & 
                                                                        int.r$A2==0)],
                                                 digits = 3), "]")
    out.table["RD.A1|A2","A2=1"] <- paste0(round(int.r$RD.A1[which(int.r$A1==1 & 
                                                                     int.r$A2==1)],
                                                 digits = 3), " [",
                                           round(int.r$RD.A1.lo[which(int.r$A1==1 & 
                                                                        int.r$A2==1)],
                                                 digits = 3), ",",
                                           round(int.r$RD.A1.up[which(int.r$A1==1 & 
                                                                        int.r$A2==1)],
                                                 digits = 3), "]")

# RR
    out.table["A1=0","RR.A2|A1"] <- paste0(round(int.r$RR.A2[which(int.r$A1==0 & 
                                                                     int.r$A2==1)], 
                                                 digits = 2), " [",
                                           round(int.r$RR.A2.lo[which(int.r$A1==0 & 
                                                                        int.r$A2==1)],
                                                 digits = 2), ",",
                                           round(int.r$RR.A2.up[which(int.r$A1==0 & 
                                                                        int.r$A2==1)],
                                                 digits = 2), "]")
    out.table["A1=1","RR.A2|A1"] <- paste0(round(int.r$RR.A2[which(int.r$A1==1 & 
                                                                     int.r$A2==1)], 
                                                 digits = 2), " [",
                                           round(int.r$RR.A2.lo[which(int.r$A1==1 & 
                                                                        int.r$A2==1)], 
                                                 digits = 2), ",",
                                           round(int.r$RR.A2.up[which(int.r$A1==1 & 
                                                                        int.r$A2==1)], 
                                                 digits = 2), "]")
    out.table["RR.A1|A2","A2=0"] <- paste0(round(int.r$RR.A1[which(int.r$A1==1 & 
                                                                     int.r$A2==0)],
                                                 digits = 2), " [",
                                           round(int.r$RR.A1.lo[which(int.r$A1==1 & 
                                                                        int.r$A2==0)],
                                                 digits = 2), ",",
                                           round(int.r$RR.A1.up[which(int.r$A1==1 & 
                                                                        int.r$A2==0)],
                                                 digits = 2), "]")
    out.table["RR.A1|A2","A2=1"] <- paste0(round(int.r$RR.A1[which(int.r$A1==1 & 
                                                                     int.r$A2==1)],
                                                 digits = 2), " [",
                                           round(int.r$RR.A1.lo[which(int.r$A1==1 & 
                                                                        int.r$A2==1)],
                                                 digits = 2), ",",
                                           round(int.r$RR.A1.up[which(int.r$A1==1 & 
                                                                        int.r$A2==1)],
                                                 digits = 2), "]")
    interaction.effects <- c(paste0("additive Interaction = ",
                                   round(int.r$a.INT[which(int.r$A1==1 & int.r$A2==1)], 
                                         digits = 3), " [",
                                   round(int.r$a.INT.lo[which(int.r$A1==1 & int.r$A2==1)], 
                                         digits = 3), ";",
                                   round(int.r$a.INT.up[which(int.r$A1==1 & int.r$A2==1)], 
                                         digits = 3), "]"),
                              paste0("RERI = ",
                                     round(int.r$RERI[which(int.r$A1==1 & int.r$A2==1)], 
                                           digits = 2), " [",
                                     round(int.r$RERI.lo[which(int.r$A1==1 & int.r$A2==1)], 
                                           digits = 2), ";",
                                     round(int.r$RERI.up[which(int.r$A1==1 & int.r$A2==1)], 
                                           digits = 2), "]"),
                              paste0("multiplicative Interaction = ",
                                     round(int.r$m.INT[which(int.r$A1==1 & int.r$A2==1)], 
                                           digits = 2), " [",
                                     round(int.r$m.INT.lo[which(int.r$A1==1 & int.r$A2==1)], 
                                           digits = 2), ";",
                                     round(int.r$m.INT.up[which(int.r$A1==1 & int.r$A2==1)], 
                                           digits = 2), "]"))

    library(kableExtra)
    kbl(out.table) %>%
      kable_classic() %>%
      footnote(general = interaction.effects)

``` 

## Estimation par Modèle Structurel Marginal

Les différentes quantités causales d'intérêt dans une analyse d'interaction peuvent être définies à partir des paramètres d'un modèle structurel marginal (_marginal structural model_, noté MSM).

Un modèle structurel marginal est un modèle qui permet de synthétiser le lien entre les potential outcomes (critères de jugement contrefactuels) et les différentes variables d'exposition d'intérêt. Ils sont particulièrement utiles dès que l'exposition a une dimensionnalité qui est plus grande que la dimensionnalité d'une variable binaire (par exemple si l'exposition est une variable quantitative continue, ou lorsqu'il existe plusieurs variables d'exposition à prendre en compte, comme dans les analyses de la médiation ou les expositions longitudinales répétées dans le temps). 

Dans l'analyse d'interaction entre deux variables binaires, on s'intéresse à 4 niveaux d'exposition $\{A_1 = 0, A_2 = 0\}$, $\{A_1 = 1, A_2 = 0\}$, $\{A_1 = 0, A_2 = 1\}$ et $\{A_1 = 1, A_2 = 1\}$. On peut synthétiser les liens entre le potential outcome $Y_{A_1,A_2}$ et les deux variables d'exposition à l'aide du MSM suivant, défini à partir de 4 paramètres $\beta$ : 
\begin{equation}
  \mathbb{E}(Y_{A_1,A_2}) = \beta_0 + \beta_1 A_1 + \beta_2 A_2 + \beta_3 (A_1 \times A_2) (\#eq:MSMinteraction)
\end{equation}

On peut redéfinir nos quantités d'intérêt pour l'analyse d'interaction en fonction des paramètres de ce modèles structurel marginal :

- Les moyennes marginales pour chaque case du tableau d'interaction
\begin{align*}
  p_{00} &= \beta_0 \\
  p_{10} &= \beta_0 + \beta_1 \\
  p_{01} &= \beta_0 + \beta_2 \\
  p_{11} &= \beta_0 + \beta_1 + \beta_2 + \beta_3
\end{align*}

- Les différences de risque, risques relatifs et mesures d'interaction peuvent ensuite se calculer comme indiqué précédemment pour la g-computation.

Les _potential outcomes_ $Y_{A_1,A_2}$ ne peuvent pas être observés directement dans une étude observationnelles, on n'est pas possible d'appliquer directement l'équation \@ref(eq:MSMinteraction) du MSM sur la base de donnée observée pour estimer les paramètres $\beta$. Différentes méthodes peuvent être appliquées pour estimer ces coefficients $\beta$, tout en prenant en compte les biais de confusion : 

  - estimation par IPTW (_Inverse probability of Treatment Weighting_), il s'agit probablement de la méthode la plus utilisée dans la littérature. Les biais de confusion sont pris en compte en appliquant une méthode de pondération aux différents participants. La pondération repose sur l'estimation des scores de propension $g(A_1)$ et $g(A_2)$ (les probabilités d'exposition à chaque variable d'intérêt $A_1$ et $A_2$). 
  - estimation par g-computation. Elle repose sur l'estimation de fonctions $\overline{Q}$ (modèles du critère de jugement) 
  - estimation par TMLE (_Targeted maximum likelihood estimation_), il s'agit d'une méthode à double robustesse qui repose à la fois l'estimation des fonctions $\overline{Q}$ et des scores de propension ($g(A_1)$ et $g(A_2)$). Cette méthode sera non-biaisée si au moins les fonctions $\overline{Q}$ ou les fonction $g$ ont été correctement estimées. L'approche par TMLE utilise des méthodes de machine learning pour estimer ces fonctions.

### Estimation du MSM par g-computation

Nous pouvons utiliser l'estimation de la fonction $\overline{Q}(A_1,A_2,L)$ réalisée précédemment au paragraphe \@ref(gcomputation) ainsi que les valeurs estimées sous les 4 scénarios contrefactuels.

1) Pour estimer les paramètres d'un MSM par g-computation, il est d'abord nécessaire de constituer une base de données constituée : 

  - d'une colonne contenant les estimations individuelles de $\mathbb{E}(Y_{A_1=a_1,A_2 = a_2})(i) = \overline{Q}_i(a_1,a_2,L)$ pour chaque scénario $\{A_1 = a_1, A_2 = a_2\}$
  - d'une colonne pour chaque variable d'exposition d'intérêt. Ici, on a besoin de deux colonnes : une colonne où $A_1 = a_1$ pour tous les individus, et une colonne où $A_2 = a_2$ pour tous les individus.
  
Initialement, la base de données contient 10 000 individus. Les _potential outcomes_ $\overline{Q}_i(a_1,a_2,L)$ ont été estimés à partir de 4 scénarios contrefactuels. On va donc constituer une base de données de 40 000 lignes.

2) On peut ensuite estimer les paramètres $\beta$ du MSM en appliquant directement l'équation \@ref(eq:MSMinteraction) sur la nouvelle base de données de 40000 lignes.

<script type="text/javascript">

// toggle visibility of R source blocks in R Markdown output
function toggle_R() {
  var x = document.getElementsByClassName('r');
  if (x.length == 0) return;
  function toggle_vis(o) {
    var d = o.style.display;
    o.style.display = (d == 'block' || d == '') ? 'none':'block';
  }

  for (i = 0; i < x.length; i++) {
    var y = x[i];
    if (y.tagName.toLowerCase() === 'pre') toggle_vis(y);
  }

    var elem = document.getElementById("myButton1");
    if (elem.value === "Hide Code") elem.value = "Show Code";
    else elem.value = "Hide Code";
}

document.write('<input onclick="toggle_R();" type="button" value="Hide Code" id="myButton1" style="position: static; top: 1%; left: 2%; z-index: 200"></input>')

</script>

```{r msm, results ='hide', cache = TRUE}

## 1) Constituer la base de données pour estimer les paramètres du MSM
# On récupère les Qbar_i prédits précédents, que l'on fusionne dans un
# même vecteur 
Y <- c(Qbar_00, Qbar_10, Qbar_01, Qbar_11)
length(Y)
# on a un vecteur de 40000 lignes

# On récupère les valeurs d'exposition qui ont servi dans les scénarios contrefactuels
# (garder le même ordre que pour les Qbar)
X <- rbind(subset(df.A1_0.A2_0, select = c("A1", "A2")), # A1 = 0, A2 = 0
           subset(df.A1_1.A2_0, select = c("A1", "A2")), # A1 = 1, A2 = 0
           subset(df.A1_0.A2_1, select = c("A1", "A2")), # A1 = 0, A2 = 1
           subset(df.A1_1.A2_1, select = c("A1", "A2"))) # A1 = 1, A2 = 1
#  dim(X) # il s'agit d'une matrice de 40000 lignes et 2 colonnes

## 2) Estimer les paramètres du MSM en appliquant l'équation (1.10) sur cette 
##    nouvelle base de donnée 'data.frame(Y,X)'
# Modèle structurel marginal
msm <- glm(Y ~ A1 + A2 + A1:A2,
           data = data.frame(Y,X),
           family = "gaussian") 
# note : il n'est pas utile d'ajuster sur les facteurs de confusion L
# car les Y ont été prédits à partir de modèles qui les déjà ont pris en compte
msm

## 3) Utilisation des paramètres du MSM afin d'estimer les quantités d'intérêt
##    pour l'analyse d'interaction
# présentation des résultats dans un tableau des effets marginaux
results.MSM <- matrix(NA, ncol = 4, nrow = 4)
colnames(results.MSM) <- c("A2 = 0", "A2 = 1",
                           "RD within strata of A1",
                           "RR within strata of A1")
rownames(results.MSM) <- c("A1 = 0", "A1 = 1",
                           "RD within strata of A2",
                           "RR within strata of A2")

# Estimation de p_00, p_10, p_01 et p_11 à partir des coefficients du MSM
results.MSM["A1 = 0","A2 = 0"] <- msm$coefficients["(Intercept)"]
results.MSM["A1 = 0","A2 = 1"] <- (msm$coefficients["(Intercept)"] +
                                     msm$coefficients["A2"])
results.MSM["A1 = 1","A2 = 0"] <- (msm$coefficients["(Intercept)"] +
                                     msm$coefficients["A1"])
results.MSM["A1 = 1","A2 = 1"] <- (msm$coefficients["(Intercept)"] +
                                     msm$coefficients["A2"] + msm$coefficients["A1"] + 
                                     msm$coefficients["A1:A2"])

# RD et RR dans les strates de A2
results.MSM["RR within strata of A2", "A2 = 0"] <- (results.MSM["A1 = 1","A2 = 0"] /
                                                      results.MSM["A1 = 0","A2 = 0"])
results.MSM["RD within strata of A2", "A2 = 0"] <- (results.MSM["A1 = 1","A2 = 0"] -
                                                      results.MSM["A1 = 0","A2 = 0"])
results.MSM["RR within strata of A2", "A2 = 1"] <- (results.MSM["A1 = 1","A2 = 1"] /
                                                      results.MSM["A1 = 0","A2 = 1"])
results.MSM["RD within strata of A2", "A2 = 1"] <- (results.MSM["A1 = 1","A2 = 1"] -
                                                      results.MSM["A1 = 0","A2 = 1"])

# RD et RR dans les strates de A1
results.MSM["A1 = 0", "RR within strata of A1"] <- (results.MSM["A1 = 0","A2 = 1"] /
                                                      results.MSM["A1 = 0","A2 = 0"])
results.MSM["A1 = 0", "RD within strata of A1"] <- (results.MSM["A1 = 0","A2 = 1"] -
                                                      results.MSM["A1 = 0","A2 = 0"])
results.MSM["A1 = 1", "RR within strata of A1"] <- (results.MSM["A1 = 1","A2 = 1"] /
                                                      results.MSM["A1 = 1","A2 = 0"])
results.MSM["A1 = 1", "RD within strata of A1"] <- (results.MSM["A1 = 1","A2 = 1"] -
                                                      results.MSM["A1 = 1","A2 = 0"])

results.MSM <- round(results.MSM,3)
RD.interaction <- msm$coefficients["A1:A2"]
RR.interaction <- ((results.MSM["A1 = 1","A2 = 1"] * results.MSM["A1 = 0","A2 = 0"]) / 
                     (results.MSM["A1 = 0","A2 = 1"] * results.MSM["A1 = 1","A2 = 0"]))
RERI <- ((results.MSM["A1 = 0","A2 = 0"] - results.MSM["A1 = 1","A2 = 0"] - 
           results.MSM["A1 = 0","A2 = 1"] + results.MSM["A1 = 1","A2 = 1"]) / 
           results.MSM["A1 = 0","A2 = 0"])
                         
```

Au final, on a (sans les IC):

```{r t_msm, echo=FALSE, warning=FALSE, message=FALSE}

interaction.effects <- c(paste0("additive Interaction = ",
                                round(RD.interaction, digits = 3)),
                         paste0("RERI = ",
                                round(RERI, digits = 3)),
                         paste0("multiplicative Interaction = ",
                                round(RR.interaction, digits = 2)))

kbl(results.MSM) %>%
  kable_classic() %>%
  footnote(general = interaction.effects)
```


### Estimation du MSM par IPTW

Les paramètres du MSM de l'équation \@ref(eq:MSMinteraction) peuvent également être estimée par une méthode de pondération inverse (IPTW).

Pour cela, il suffit d'appliquer une régression pondérée correspondant à l'équation \@ref(eq:MSMinteraction), où chaque individu $i$ est pondéré par $w_i$ le produit l'inverse des scores de propension de l'exposition $A_1$ et de l'exposition $A_2$ (pour rappel, d'après le DAG simulant les données, les parents de $A_1$ sont $L_1$ et $L_2$, et les parents de $A_2$ sont $L_2$ et $L_3$) :
\begin{equation*}
  w_i = \frac{g^*(A_{1,i})}{g(A_{1,i} \mid L_1, L_2)} \times \frac{g^*(A_{2,i})}{g(A_{2,i} \mid L_2, L_3)}
\end{equation*}
où 

  - $g^*(A_i)$ sont des fonctions choisies par l'utilisateur, par exemple $g^*(A_i) = 1$ correspondant à une pondération IPTW simple, ou encore $g^*(A_i) = g(A_i)$ qui permet de stabiliser les estimations (_stabilized IPTW_)
  - $g(A_i \mid L)$ sont les scores de propension : ils modélisent la probabilité d'observer sa propre exposition. 

\begin{equation*}
 g(A_i \mid L) = \left\{
  \begin{array}{ll}
    P(A = 1 \mid L_i) & \mbox{ si } A_i = 1 \\
    1 - P(A = 1 \mid L_i) & \mbox{ si } A_i = 0 
  \end{array}
 \right.
\end{equation*}
  
Cette pondération permet de créer une "pseudo-population" dans laquelle les facteurs de confusion des relations $A_1 \rightarrow Y$ et $A_2 \rightarrow Y$ sont équilibrés entre les strates d'exposition.

```{r msm_iptw, results ='hide', cache = TRUE}

### Par exemple pour calculer des poids stabilisés : 
## 1) estimer les fonctions g(A_1)*, g(A_1 | L1, L2), g(A_2*), g(A_2 | L2, L3)
model_gA1_star <- glm(A1 ~ 1, data = df, family = "binomial")
model_gA1 <- glm(A1 ~ L1 + L2, data = df, family = "binomial")
p_A1is1_star <- predict(model_gA1_star, type = "response")
p_A1is1 <- predict(model_gA1, type = "response")

model_gA2_star <- glm(A2 ~ 1, data = df, family = "binomial")
model_gA2 <- glm(A2 ~ L2 + L3, data = df, family = "binomial")
p_A2is1_star <- predict(model_gA2_star, type = "response")
p_A2is1 <- predict(model_gA2, type = "response")

gA1_star <- gA1 <- rep(NA, nrow(df))
gA1_star[df$A1 == 1] <- p_A1is1_star[df$A1 == 1]
gA1_star[df$A1 == 0] <- 1 - p_A1is1_star[df$A1 == 0]
gA1[df$A1 == 1] <- p_A1is1[df$A1 == 1]
gA1[df$A1 == 0] <- 1 - p_A1is1[df$A1 == 0]

gA2_star <- gA2 <- rep(NA, nrow(df))
gA2_star[df$A2 == 1] <- p_A2is1_star[df$A2 == 1]
gA2_star[df$A2 == 0] <- 1 - p_A2is1_star[df$A2 == 0]
gA2[df$A2 == 1] <- p_A2is1[df$A2 == 1]
gA2[df$A2 == 0] <- 1 - p_A2is1[df$A2 == 0]

# On peut alors calculer les poids individuels stabilisés
sw <- (gA1_star / gA1) * (gA2_star / gA2)

## 2) Estimer les coefficients du MSM à l'aide d'une régression pondérée
# L'équation (1.10) correspond à un modèle additif, 
# nous allons utiliser une régression linéaire (family = gaussian)
msm_iptw <- glm(Y ~ A1 + A2 + A1:A2, data = df, family = "gaussian",
                weights = sw)

msm_iptw

## 3) Utilisation des paramètres du MSM afin d'estimer les quantités d'intérêt
##    pour l'analyse d'interaction
# présentation des résultats dans un tableau des effets marginaux
results.MSM <- matrix(NA, ncol = 4, nrow = 4)
colnames(results.MSM) <- c("A2 = 0", "A2 = 1",
                           "RD within strata of A1",
                           "RR within strata of A1")
rownames(results.MSM) <- c("A1 = 0", "A1 = 1",
                           "RD within strata of A2",
                           "RR within strata of A2")

# Estimation de p_00, p_10, p_01 et p_11 à partir des coefficients du MSM
results.MSM["A1 = 0","A2 = 0"] <- msm_iptw$coefficients["(Intercept)"]
results.MSM["A1 = 0","A2 = 1"] <- (msm_iptw$coefficients["(Intercept)"] +
                                     msm_iptw$coefficients["A2"])
results.MSM["A1 = 1","A2 = 0"] <- (msm_iptw$coefficients["(Intercept)"] +
                                     msm_iptw$coefficients["A1"])
results.MSM["A1 = 1","A2 = 1"] <- (msm_iptw$coefficients["(Intercept)"] +
                                     msm_iptw$coefficients["A2"] + 
                                     msm_iptw$coefficients["A1"] + 
                                     msm_iptw$coefficients["A1:A2"])

# RD et RR dans les strates de A2
results.MSM["RR within strata of A2", "A2 = 0"] <- (results.MSM["A1 = 1","A2 = 0"] /
                                                      results.MSM["A1 = 0","A2 = 0"])
results.MSM["RD within strata of A2", "A2 = 0"] <- (results.MSM["A1 = 1","A2 = 0"] -
                                                      results.MSM["A1 = 0","A2 = 0"])
results.MSM["RR within strata of A2", "A2 = 1"] <- (results.MSM["A1 = 1","A2 = 1"] /
                                                      results.MSM["A1 = 0","A2 = 1"])
results.MSM["RD within strata of A2", "A2 = 1"] <- (results.MSM["A1 = 1","A2 = 1"] -
                                                      results.MSM["A1 = 0","A2 = 1"])

# RD et RR dans les strates de A1
results.MSM["A1 = 0", "RR within strata of A1"] <- (results.MSM["A1 = 0","A2 = 1"] /
                                                      results.MSM["A1 = 0","A2 = 0"])
results.MSM["A1 = 0", "RD within strata of A1"] <- (results.MSM["A1 = 0","A2 = 1"] -
                                                      results.MSM["A1 = 0","A2 = 0"])
results.MSM["A1 = 1", "RR within strata of A1"] <- (results.MSM["A1 = 1","A2 = 1"] /
                                                      results.MSM["A1 = 1","A2 = 0"])
results.MSM["A1 = 1", "RD within strata of A1"] <- (results.MSM["A1 = 1","A2 = 1"] -
                                                      results.MSM["A1 = 1","A2 = 0"])

results.MSM <- round(results.MSM,3)
RD.interaction <- msm_iptw$coefficients["A1:A2"]
RR.interaction <- ((results.MSM["A1 = 1","A2 = 1"] * results.MSM["A1 = 0","A2 = 0"]) / 
                     (results.MSM["A1 = 0","A2 = 1"] * results.MSM["A1 = 1","A2 = 0"]))
RERI <- ((results.MSM["A1 = 0","A2 = 0"] - results.MSM["A1 = 1","A2 = 0"] - 
           results.MSM["A1 = 0","A2 = 1"] + results.MSM["A1 = 1","A2 = 1"]) / 
           results.MSM["A1 = 0","A2 = 0"])
                         
```

Au final, on a (sans les IC):

```{r t_msm_itpw, echo=FALSE, message=FALSE, warning=FALSE}

interaction.effects <- c(paste0("additive Interaction = ",
                                round(RD.interaction, digits = 3)),
                         paste0("RERI = ",
                                round(RERI, digits = 3)),
                         paste0("multiplicative Interaction = ",
                                round(RR.interaction, digits = 2)))

kbl(results.MSM) %>%
  kable_classic() %>%
  footnote(general = interaction.effects)
```



## Estimation avec TMLE

Le package R `ltmle` contient la fonction `ltmleMSM` qui permet d'estimer les paramètres d'un modèle structurel marginal par TMLE, par IPTW ou par g-computation. Par contre, le MSM utilisé est nécessairement une régression logistique. Les résultats que l'on peut en déduire sont donc des Odds Ratios ou une approximation du RERI, comme cela a été fait au paragraphe \@ref(regressionlogistique).

Il est possible d'estimer les différences de risque, risques relatifs, et les différentes mesures d'interaction à partir de ce MSM défini sous forme de régression logistique, mais les calculs manuels sont plus fastidieux. Par ailleurs, les calculs d'intervalles de confiance reposent sur une delta-méthode.

Nous avons développé un package `MargIntTmle` disponible sur cette [page Github](https://github.com/benoitlepage/MargIntTmle), qui permet de faire ces calculs automatiquement. Vous trouverez la documentation complète du package sur la page.

Ci-dessous nous illustrons l'utilisation du package `MargIntTmle` pour obtenir des estimations par g-computation, IPTW, ou TMLE. 

<script type="text/javascript">

// toggle visibility of R source blocks in R Markdown output
function toggle_R() {
  var x = document.getElementsByClassName('r');
  if (x.length == 0) return;
  function toggle_vis(o) {
    var d = o.style.display;
    o.style.display = (d == 'block' || d == '') ? 'none':'block';
  }

  for (i = 0; i < x.length; i++) {
    var y = x[i];
    if (y.tagName.toLowerCase() === 'pre') toggle_vis(y);
  }

    var elem = document.getElementById("myButton1");
    if (elem.value === "Hide Code") elem.value = "Show Code";
    else elem.value = "Hide Code";
}

document.write('<input onclick="toggle_R();" type="button" value="Hide Code" id="myButton1" style="position: static; top: 1%; left: 2%; z-index: 200"></input>')

</script>

```{r tmle, echo=TRUE, message=FALSE, warning=FALSE, cache=TRUE}
# L'installation du package peut se faire depuis la commande 
# devtools::install_github("benoitlepage/MargIntTmle")
library(MargIntTmle)

# le package 'MargIntTmle' repose sur les package 'ltmle' et 'SuperLearner'
require(ltmle)
require(SuperLearner)

## Parmi les arguments nécessaires, il faut indiquer les fonctions Q et g
# Fonction Q
Q_formulas = c(Y="Q.kplus1 ~ A1 + A2 + A1 * A2 + L1 + L2 + L3")
# Les deux fonctions g 
g_formulas = c("A1 ~ L1 + L2",
               "A2 ~ L2 + L3")

## Choisir des librairies de machine learning disponibles dans le package 'SuperLearner':
SL.library = list(Q=list("SL.glm"),g=list("SL.glm"))

## Utilisation de la fonction 'int.ltmleMSM()'
# Cette fonction va estimer les paramètres du MSM soit par g-computation, 
# soit par TMLE et IPTW

# Pour obtenir une estimation des paramètres du MSM par TMLE et par IPTW, l'argument 
# 'gcomp' doit égal à FALSE
interaction.ltmle <- int.ltmleMSM(data = df,
                                  Qform = Q_formulas,
                                  gform = g_formulas,
                                  Anodes = c("A1", "A2"),
                                  Lnodes = c("L1", "L2", "L3"),
                                  Ynodes = c("Y"),
                                  SL.library = SL.library,
                                  gcomp = FALSE, # pour l'estimation par TMLE et IPTW
                                  iptw.only = FALSE,
                                  survivalOutcome = FALSE,
                                  variance.method = "ic")

# Pour obtenir une estimation des paramètres du MSM par g-computation, l'argument
# 'gcomp' doit être égal à TRUE. 
# Les IC95% seront alors estimés par bootstrap, vous pouvez préciser le nombre 
# d'échantillons bootstrap et donner une valeur de seed
interaction.gcomp <- int.ltmleMSM(data = df,
                                  Qform = Q_formulas,
                                  gform = g_formulas,
                                  Anodes = c("A1", "A2"),
                                  Lnodes = c("L1", "L2", "L3"),
                                  Ynodes = c("Y"),
                                  SL.library = SL.library,
                                  gcomp = TRUE, # pour l'estimation par g-computation
                                  iptw.only = FALSE,
                                  survivalOutcome = FALSE,
                                  variance.method = "ic",
                                  B = 1000, # number of bootstrap samples
                                  boot.seed = 42) # seed for bootstrap

## La fonction 'estim.int.effects()' permet d'estimer les différentes quantités 
## d'intérêt pour l'analyse d'interaction à partir du MSM estimé précédemment.
# Les IC95% sont calculés par Delta méthode pour la TMLE et l'IPTW, et par 
# bootstrap pour la g-computation.

# pour obtenir les estimations par TMLE : 
est.tmle <- estim.int.effects(interaction.ltmle, estimator = "tmle")

# pour obtenir les estimations par IPTW : 
est.iptw <- estim.int.effects(interaction.ltmle, estimator = "iptw")

# pour obtenir les estimations par g-computation : 
est.gcomp <- estim.int.effects(interaction.gcomp, estimator = "gcomp")

## Les résultats peuvent ensuite être présentés sous forme de table, en suivant 
## les recommandations de Knol et al. (2012) à l'aide de la fonction 'out.int.table()'

# par exemple pour les estimations par TMLE : 
table_inter <- out.int.table(int.r = est.tmle)
table_inter$out.table

# les mesures d'interaction sont disponible dans l'objet 
table_inter$interaction.effects
```


On peut également se servir du package `KableExtra` pour mettre en forme les tables (selon les recommandations Knol et al. @knol_recommendations_2012) :

Effets d'interaction estimés par TMLE : 
```{r t_tab_tmle, echo=TRUE, message=FALSE, warning=FALSE}
library(knitr)
knitr::kable(table_inter$out.table,) %>%
  kable_classic() %>%
  add_footnote(c(table_inter$interaction.effects[1], 
                 table_inter$interaction.effects[2], 
                 table_inter$interaction.effects[3]),
               escape = TRUE)
```

Résultats obtenus en appliquant l'estimation par IPTW : 
```{r t_tab_iptw, echo=TRUE, message=FALSE, warning=FALSE}
table_inter <- MargIntTmle::out.int.table(int.r = est.iptw)
knitr::kable(table_inter$out.table,) %>%
  kable_classic() %>%
  add_footnote(c(table_inter$interaction.effects[1], 
                 table_inter$interaction.effects[2], 
                 table_inter$interaction.effects[3]),
               escape = TRUE)
```

Résultats obtenus en appliquant l'estimation par g-computation : 
```{r t_tab_gcomp, echo=TRUE, message=FALSE, warning=FALSE}
table_inter <- MargIntTmle::out.int.table(int.r = est.gcomp)
knitr::kable(table_inter$out.table,) %>%
  kable_classic() %>%
  add_footnote(c(table_inter$interaction.effects[1], 
                 table_inter$interaction.effects[2], 
                 table_inter$interaction.effects[3]),
               escape = TRUE)
```




